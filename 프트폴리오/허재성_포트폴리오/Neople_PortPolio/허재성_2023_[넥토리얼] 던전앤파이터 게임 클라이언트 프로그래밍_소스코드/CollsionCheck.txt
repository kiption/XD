
[플레이어-맵 충돌]
void collisioncheck_Player2Map(int client_id) {
	MyVector3D cur_pos = clients[client_id].getPos();
	// 맵의 끝으로부터 너무 멀리떨어져 있다면 충돌체크 및 후처리를 하지 않습니다.
	if (cur_pos.x > MAP_X_MIN + MAP_COLLISIONCHECK_RANGE && cur_pos.x < MAP_X_MAX - MAP_COLLISIONCHECK_RANGE &&
		cur_pos.z > MAP_Z_MIN + MAP_COLLISIONCHECK_RANGE && cur_pos.z < MAP_Z_MAX - MAP_COLLISIONCHECK_RANGE)
		return;

	if (cur_pos.x < MAP_X_MIN) {
		cur_pos.x = MAP_X_MIN;
		// Update
		EnterCriticalSection(&clients[client_id].m_cs);
		clients[client_id].setPos(cur_pos);
		LeaveCriticalSection(&clients[client_id].m_cs);
	}
	else if (cur_pos.x > MAP_X_MAX) {
		cur_pos.x = MAP_X_MAX;
		// Update
		EnterCriticalSection(&clients[client_id].m_cs);
		clients[client_id].setPos(cur_pos);
		LeaveCriticalSection(&clients[client_id].m_cs);
	}

	if (cur_pos.z < MAP_Z_MIN) {
		cur_pos.z = MAP_Z_MIN;
		// Update
		EnterCriticalSection(&clients[client_id].m_cs);
		clients[client_id].setPos(cur_pos);
		LeaveCriticalSection(&clients[client_id].m_cs);
	}
	else if (cur_pos.z > MAP_Z_MAX) {
		cur_pos.z = MAP_Z_MAX;
		// Update
		EnterCriticalSection(&clients[client_id].m_cs);
		clients[client_id].setPos(cur_pos);
		LeaveCriticalSection(&clients[client_id].m_cs);
	}
}


[플레이어-아이템 박스 충돌]
void collisioncheck_Player2ItemBox(int client_id)
{
	for (int i = 0; i < ITEMBOXNUM; i++)
	{
		// 이미 누군가가 최근에 충돌한 적있는 아이템박스는 충돌체크 대상에서 제외합니다.
		if (!ItemBoxArray[i].m_visible) continue;

		// 플레이어에게서 너무 멀리 떨어져있는 아이템박스는 충돌체크 대상에서 제외합니다.
		if (ItemBoxArray[i].m_pos.x < clients[client_id].getPos().x - 150
			|| ItemBoxArray[i].m_pos.x > clients[client_id].getPos().x + 150) continue;
		if (ItemBoxArray[i].m_pos.y < clients[client_id].getPos().y - 100
			|| ItemBoxArray[i].m_pos.y > clients[client_id].getPos().y + 100) continue;
		if (ItemBoxArray[i].m_pos.z < clients[client_id].getPos().z - 150
			|| ItemBoxArray[i].m_pos.z > clients[client_id].getPos().z + 150) continue;

		// 충돌체크 & 후처리
		if (ItemBoxArray[i].xoobb.Intersects(clients[client_id].xoobb))
		{
			// 아이템 박스를 안보이게 위치를 조정하고, 충돌체크 대상에서 제외되도록 설정합니다.
			EnterCriticalSection(&ItemBoxArray[i].m_cs);
			ItemBoxArray[i].m_pos.y = ItemBoxArray[i].m_pos.y - 500;
			ItemBoxArray[i].m_visible = false;
			LeaveCriticalSection(&ItemBoxArray[i].m_cs);

			// 아이템 박스의 변경사항을 모든 클라이언트에게 전달합니다.
			sendItemBoxUpdatePacket_toAllClient(i);

			// 충돌한 아이템박스는 5.0초 후에 초기상태로 돌아옵니다.
			EnterCriticalSection(&cs_timer_event);
			setServerEvent(EV_TYPE_REFRESH, 5.0f, EV_TARGET_ITEMBOX, 0, i, 0, 0);
			LeaveCriticalSection(&cs_timer_event);

			// 충돌한 플레이어는 갖고 있는 아이템이 2개 미만일 때에만 새로운 아이템을 얻을 수 있습니다.
			if (clients[client_id].getHowManyItem() < 2) {
				srand(static_cast<unsigned int>(SERVER_TIME) * i);
				int new_item = rand() % 3;
				//int new_item = 0;

				EnterCriticalSection(&clients[client_id].m_cs);
				clients[client_id].setItemQueue(new_item);
				LeaveCriticalSection(&clients[client_id].m_cs);

				cout << "Collide ItemBox[" << i << "], and... ";
				cout << "Get New Item(type: " << new_item << ")." << endl;
			}
			else {
				cout << "Failed to Get New Item - You Have Too Many Items..." << endl;
			}
		}
	}
}

[플레이어-트랩 충돌]
void collisioncheck_Player2Bomb(int client_id)
{
	for (int i = 0; i < BombNum; i++) {
		// 작동하지 않는 지뢰는 충돌체크 대상에서 제외합니다.
		if (!BombArray[i].getRunning()) continue;

		// 피격 모션 중인 플레이어는 공격하지 않습니다.
		if (clients[client_id].getHitMotion()) continue;

		// 플레이어에게서 너무 멀리 떨어져있는 지뢰는 충돌체크 대상에서 제외합니다.
		if (BombArray[i].getPos().x < clients[client_id].getPos().x - 150
			|| BombArray[i].getPos().x > clients[client_id].getPos().x + 150) continue;
		if (BombArray[i].getPos().y < clients[client_id].getPos().y - 100
			|| BombArray[i].getPos().y > clients[client_id].getPos().y + 100) continue;
		if (BombArray[i].getPos().z < clients[client_id].getPos().z - 150
			|| BombArray[i].getPos().z > clients[client_id].getPos().z + 150) continue;


		// 충돌체크 & 후처리
		if (BombArray[i].xoobb.Intersects(clients[client_id].xoobb))
		{
			EnterCriticalSection(&clients[client_id].m_cs);
			// 피격모션
			clients[client_id].setLoseControl(true);
			clients[client_id].setHitMotion(true);
			// 지뢰 삭제
			BombArray[i].returnToInitialState();
			LeaveCriticalSection(&clients[client_id].m_cs);

			// 지뢰 제거 패킷을 모든 클라이언트에게 전달합니다.
			GS2C_REMOVE_OBJ_PACKET rm_bomb_packet;
			rm_bomb_packet.type = GS2C_REMOVE_OBJ;
			rm_bomb_packet.id = i;
			rm_bomb_packet.objtype = OBJ_TYPE_BOMB;
			for (int j = 0; j < MAX_USER; j++) {
				if (clients[j].getState() == CL_STATE_EMPTY) continue;
				clients[j].sendRemoveObjPacket(rm_bomb_packet);
			}

			EnterCriticalSection(&cs_timer_event);
			setServerEvent(EV_TYPE_HIT_BOMB, HIT_BOMB_DURATION, EV_TARGET_CLIENTS, 0, client_id, 0, 0);
			LeaveCriticalSection(&cs_timer_event);
		}
	}
}


[플레이어-미사일 충돌]
void collisioncheck_Player2Missile(int client_id)
{
	for (int i = 0; i < MissileNum; i++) {
		// 작동하지 않는 미사일은 충돌체크 대상에서 제외합니다.
		if (!MissileArray[i].getRunning()) continue;

		// 자신을 생성한 플레이어는 공격하지 않습니다.
		if (MissileArray[i].getObjOwner() == client_id) continue;

		// 피격 모션 중인 플레이어는 공격하지 않습니다.
		if (clients[client_id].getHitMotion()) continue;

		// 플레이어에게서 너무 멀리 떨어져있는 미사일은 충돌체크 대상에서 제외합니다.
		if (MissileArray[i].getPos().x < clients[client_id].getPos().x - 150
			|| MissileArray[i].getPos().x > clients[client_id].getPos().x + 150) continue;
		if (MissileArray[i].getPos().y < clients[client_id].getPos().y - 100
			|| MissileArray[i].getPos().y > clients[client_id].getPos().y + 100) continue;
		if (MissileArray[i].getPos().z < clients[client_id].getPos().z - 150
			|| MissileArray[i].getPos().z > clients[client_id].getPos().z + 150) continue;


		// 충돌체크 & 후처리
		if (MissileArray[i].xoobb.Intersects(clients[client_id].xoobb))
		{
			EnterCriticalSection(&clients[client_id].m_cs);
			// 피격모션
			clients[client_id].setLoseControl(true);
			clients[client_id].setHitMotion(true);
			// 미사일 삭제
			MissileArray[i].returnToInitialState();
			LeaveCriticalSection(&clients[client_id].m_cs);

			// 미사일 제거 패킷을 모든 클라이언트에게 전달합니다.
			GS2C_REMOVE_OBJ_PACKET rm_missile_packet;
			rm_missile_packet.type = GS2C_REMOVE_OBJ;
			rm_missile_packet.id = i;
			rm_missile_packet.objtype = OBJ_TYPE_MISSILE;
			for (int j = 0; j < MAX_USER; j++) {
				if (clients[j].getState() == CL_STATE_EMPTY) continue;
				clients[j].sendRemoveObjPacket(rm_missile_packet);
			}

			EnterCriticalSection(&cs_timer_event);
			setServerEvent(EV_TYPE_HIT, HIT_MISSILE_DURATION, EV_TARGET_CLIENTS, 0, client_id, 0, 0);
			LeaveCriticalSection(&cs_timer_event);
		}
	}
}